# Dynamic Programming => 마지막 케이스를 생각해라

아래 조건을 모두 만족할 때 사용할 수 있다. 
1. 최적 부분 구조
   - 큰 문제를 작은 문제로 나눌 수 있다. 
   - 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다. 
   - **작은 문제들은 서로 독립적**이어야 한다. 서로 영향을 주면 안 된다!!!
2. 중복되는 부분 문제
   - 동일한 작은 문제를 반복적으로 해결해야 한다.

## DP를 구현하는 방법

> 탑다운 방식 == 메모이제이션 (캐싱) -> 재귀를 활용한다

같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.

> 바텀업 방식 -> 반복문을 사용한다

DP의 전형적인 형태
결과 저장용 리스트는 DP 테이블이라고 부른다. 


```py
# 탑다운 다이나믹 프로그래밍 소스코드
cache = [0] * 100

def fibonacci(x):
    # 종료조건
    if x == 1 or x =-2:
        return 1
    # 이미 계산한 적 있다면 그대로 리턴
    if cache[x] != 0:
        return cache[x]
    # 아직 계산한 적 없는 문제면 캐시에 저장해준다
    cache[x] = fibonacci(x-1) + fibonacci(x-2)
    return cache[x]

# 바텀업 방식
# 작은 문제를 해결해놓고 점점 큰 문제로
def fibonacci2(x):
    d = [0] * 199

    d[1] = 1
    d[2] = 1
    n = 99

    for i in range(3, n+1):
        d[i] = d[i - 1] + d[i - 2]

fibonacci(99)

```

# 다이나믹 프로그래밍 (피보나치) VS 분할 정복 (퀵소트)

- 모두 최적 부분 구조를 가질 때 사용할 수 있다. 
  - 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는가?
- 두개의 큰 차이점은 부분 문제의 중복이다. 
  - 다이나믹 프로그래밍 : 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다. 
  - 분할 정복 : 동일한 부분 문제가 반복적으로 계산되지 않는다. -> 퀵소트의 경우.. 분할이 한 번 일어나면 다시 계산되는 일은 없다

## 동적계획법 문제 접근 방법

- 주어진 문제가 다이나믹 프로그래밍 유형인지 파악
- 그리디, 구현, 완탐으로 해결되는지 검토
- 일단 재귀로 비효율적인 완전 탐색 프로그램을 작성한 뒤에, 작은 문제에서 구한 답을 큰 문제에서 그대로 사용할 수 있다면, 
    
    캐시를 사용해 메모이제이션한다!